# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: queries.sql
import dataclasses
import decimal
from typing import Optional

import sqlalchemy

from rl_playground.go_explore import models


CELL_EXISTS = """-- name: cell_exists \\:one
SELECT EXISTS(
    SELECT 1
    FROM cells
    WHERE hash = :p1
)
"""


GET_CELL = """-- name: get_cell \\:one
SELECT id, action, max_no_ops, initial, state
FROM cells
WHERE id = :p1
"""


@dataclasses.dataclass()
class GetCellRow:
    id: int
    action: Optional[int]
    max_no_ops: Optional[int]
    initial: bool
    state: memoryview


GET_FIRST_CELL = """-- name: get_first_cell \\:one
SELECT id, action, max_no_ops, initial, state
FROM cells
ORDER BY id
LIMIT 1
"""


@dataclasses.dataclass()
class GetFirstCellRow:
    id: int
    action: Optional[int]
    max_no_ops: Optional[int]
    initial: bool
    state: memoryview


GET_RANDOM_CELL = """-- name: get_random_cell \\:one
WITH mean_scores AS (
    -- get mean of last 10 scores of all cells in certain sections
    SELECT cell_id, AVG(score) AS mean_score
    FROM (
        SELECT cs.cell_id, cs.score, ROW_NUMBER() OVER (PARTITION BY cs.cell_id ORDER BY cs.id DESC) AS rn
        FROM cell_scores AS cs
        JOIN cells AS c
        ON c.id = cs.cell_id
        WHERE c.section <= :p1
    ) AS desc_scores
    WHERE rn <= 10
    GROUP BY cell_id
), norm_scores AS (
    -- normalize mean scores to be between 0 and 100
    SELECT 
        cell_id,
        -- ensure we aren't dividing by 0
        ((mean_score - min_score) / COALESCE(NULLIF(max_score - min_score, 0), 1)) * 100 AS norm_score
    FROM (
        SELECT 
            cell_id,
            mean_score,
            MIN(mean_score) OVER () AS min_score,
            MAX(mean_score) OVER () AS max_score
        FROM mean_scores
    ) AS q
), weights AS (
    -- create weights for each cell based on number of visits and normalized score
    -- less visits and a lower normalized score results in a higher weight
    -- normalized score is prioritized over number of visits
    SELECT 
        c.id AS id,
        (100 / SQRT(c.visits + 1)) + (
            -- subtract normalized scores by max normalized score so
            -- cells with a greater normalized score have less weight
            (
                SELECT MAX(norm_score) AS max_score
                FROM norm_scores
            ) - SUM(ns.norm_score)
        ) AS weight
    FROM cells AS c
    JOIN norm_scores AS ns
    ON ns.cell_id = c.id
    GROUP BY c.id
), rand_pick AS (
    -- create value that will be used to pick a random cell
    -- multiply random number by sum of all weights so the weights don't have to add up to 100
    SELECT random() * (SELECT SUM(weight) FROM weights) AS pick
), rand_id AS (
    SELECT id
    FROM (
        SELECT id, SUM(weight) OVER (ORDER BY id) AS scaled_weight, pick
        FROM weights CROSS JOIN rand_pick
    ) AS q
    WHERE scaled_weight >= pick
    ORDER BY id
    LIMIT 1
)
SELECT c.id, action, max_no_ops, initial, state
FROM cells AS c
JOIN rand_id AS ri ON ri.id = c.id WHERE c.id = ri.id
"""


@dataclasses.dataclass()
class GetRandomCellRow:
    id: int
    action: Optional[int]
    max_no_ops: Optional[int]
    initial: bool
    state: memoryview


INCREMENT_CELL_VISIT = """-- name: increment_cell_visit \\:exec
UPDATE cells
SET visits = visits + 1
WHERE id = :p1
"""


INSERT_CELL = """-- name: insert_cell \\:one
INSERT INTO cells (
    hash, action, max_no_ops, initial, section, state
) VALUES (
    :p1, :p2, :p3, :p4, :p5, :p6
)
ON CONFLICT DO NOTHING
RETURNING id
"""


INSERT_CELL_SCORE = """-- name: insert_cell_score \\:exec
INSERT INTO cell_scores (
    cell_id, score
) VALUES (
    :p1, :p2
)
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def cell_exists(self, *, hash: str) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(CELL_EXISTS), {"p1": hash}).first()
        if row is None:
            return None
        return row[0]

    def get_cell(self, *, id: int) -> Optional[GetCellRow]:
        row = self._conn.execute(sqlalchemy.text(GET_CELL), {"p1": id}).first()
        if row is None:
            return None
        return GetCellRow(
            id=row[0],
            action=row[1],
            max_no_ops=row[2],
            initial=row[3],
            state=row[4],
        )

    def get_first_cell(self) -> Optional[GetFirstCellRow]:
        row = self._conn.execute(sqlalchemy.text(GET_FIRST_CELL)).first()
        if row is None:
            return None
        return GetFirstCellRow(
            id=row[0],
            action=row[1],
            max_no_ops=row[2],
            initial=row[3],
            state=row[4],
        )

    def get_random_cell(self, *, section: str) -> Optional[GetRandomCellRow]:
        row = self._conn.execute(sqlalchemy.text(GET_RANDOM_CELL), {"p1": section}).first()
        if row is None:
            return None
        return GetRandomCellRow(
            id=row[0],
            action=row[1],
            max_no_ops=row[2],
            initial=row[3],
            state=row[4],
        )

    def increment_cell_visit(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(INCREMENT_CELL_VISIT), {"p1": id})

    def insert_cell(self, *, hash: str, action: Optional[int], max_no_ops: Optional[int], initial: bool, section: str, state: memoryview) -> Optional[int]:
        row = self._conn.execute(sqlalchemy.text(INSERT_CELL), {
            "p1": hash,
            "p2": action,
            "p3": max_no_ops,
            "p4": initial,
            "p5": section,
            "p6": state,
        }).first()
        if row is None:
            return None
        return row[0]

    def insert_cell_score(self, *, cell_id: int, score: decimal.Decimal) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_CELL_SCORE), {"p1": cell_id, "p2": score})
