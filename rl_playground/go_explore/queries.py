# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.25.0
# source: queries.sql
import dataclasses
import decimal
from typing import Optional

import sqlalchemy

from go_explore import models


CELL_EXISTS = """-- name: cell_exists \\:one
SELECT EXISTS(
    SELECT 1
    FROM cells
    WHERE hash = :p1
)
"""


GET_RANDOM_CELL = """-- name: get_random_cell \\:one
WITH mean_scores AS (
    SELECT cs.cell_id AS cell_id, AVG(score) AS mean_score
    FROM cell_scores AS cs
    GROUP BY cs.cell_id
    ORDER BY cs.cell_id DESC
    LIMIT 100
), weights AS (
    SELECT c.id AS id, (100 / SQRT(c.visits + 1)) + SUM(ms.mean_score) AS weight
    FROM cells AS c
    JOIN mean_scores AS ms
    ON ms.cell_id = c.id
    GROUP BY c.id
), rand_pick AS (
    SELECT random() * (SELECT SUM(weight) FROM weights) pick
), rand_id AS (
    SELECT id
    FROM (
        SELECT id, SUM(weight) OVER (ORDER BY id) scaled_weight, pick
        FROM weights CROSS JOIN rand_pick
    ) q
    WHERE scaled_weight >= pick
    ORDER BY id
    LIMIT 1
)
SELECT c.id, action, max_no_ops, initial, state
FROM cells AS c
JOIN rand_id AS ri ON ri.id = c.id WHERE c.id = ri.id
"""


@dataclasses.dataclass()
class GetRandomCellRow:
    id: int
    action: Optional[int]
    max_no_ops: Optional[int]
    initial: bool
    state: memoryview


INSERT_CELL = """-- name: insert_cell \\:exec
INSERT INTO cells (
    hash, action, max_no_ops, initial, state
) VALUES (
    :p1, :p2, :p3, :p4, :p5
)
"""


INSERT_CELL_SCORE = """-- name: insert_cell_score \\:exec
INSERT INTO cell_scores (
    cell_id, score
) VALUES (
    :p1, :p2
)
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def cell_exists(self, *, hash: str) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(CELL_EXISTS), {"p1": hash}).first()
        if row is None:
            return None
        return row[0]

    def get_random_cell(self) -> Optional[GetRandomCellRow]:
        row = self._conn.execute(sqlalchemy.text(GET_RANDOM_CELL)).first()
        if row is None:
            return None
        return GetRandomCellRow(
            id=row[0],
            action=row[1],
            max_no_ops=row[2],
            initial=row[3],
            state=row[4],
        )

    def insert_cell(self, *, hash: str, action: Optional[int], max_no_ops: Optional[int], initial: bool, state: memoryview) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_CELL), {
            "p1": hash,
            "p2": action,
            "p3": max_no_ops,
            "p4": initial,
            "p5": state,
        })

    def insert_cell_score(self, *, cell_id: int, score: decimal.Decimal) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_CELL_SCORE), {"p1": cell_id, "p2": score})
